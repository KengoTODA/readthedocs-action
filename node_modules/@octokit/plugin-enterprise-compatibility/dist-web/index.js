import { RequestError } from '@octokit/request-error';

const VERSION = "1.2.1";

function isIssueLabelsUpdateOrReplace({ method, url }) {
    if (!["POST", "PUT"].includes(method)) {
        return false;
    }
    if (!/\/repos\/[^/]+\/[^/]+\/issues\/[^/]+\/labels/.test(url)) {
        return false;
    }
    return true;
}

const REGEX_IS_GET_REFERENCE_PATH = /\/repos\/[^/]+\/[^/]+\/git\/ref\//;
const REGEX_IS_LIST_REFERENCES_PATH = /\/repos\/[^/]+\/[^/]+\/git\/matching-refs\//;
function isGetReference({ method, url }) {
    if (!["GET", "HEAD"].includes(method)) {
        return false;
    }
    return REGEX_IS_GET_REFERENCE_PATH.test(url);
}
function isListReferences({ method, url }) {
    if (!["GET", "HEAD"].includes(method)) {
        return false;
    }
    return REGEX_IS_LIST_REFERENCES_PATH.test(url);
}

function enterpriseCompatibility(octokit) {
    octokit.hook.wrap("request", async (request, options) => {
        // see https://github.com/octokit/rest.js/blob/15.x/lib/routes.json#L3046-L3068
        if (isIssueLabelsUpdateOrReplace(options)) {
            options.data = options.labels;
            delete options.labels;
            // for @octokit/rest v16.x, remove validation of labels option
            if (options.request.validate) {
                delete options.request.validate.labels;
            }
            return request(options);
        }
        const isGetReferenceRequest = isGetReference(options);
        const isListReferencesRequest = isListReferences(options);
        if (isGetReferenceRequest || isListReferencesRequest) {
            options.url = options.url.replace(/\/repos\/([^/]+)\/([^/]+)\/git\/(ref|matching-refs)\/(.*)$/, "/repos/$1/$2/git/refs/$4");
            return request(options)
                .then((response) => {
                if (isGetReferenceRequest) {
                    if (Array.isArray(response.data)) {
                        throw new RequestError(`More than one reference found at "${options.url}"`, 404, {
                            request: options
                        });
                    }
                    // âœ… received single reference
                    return response;
                }
                // make sure that
                if (!Array.isArray(response.data)) {
                    response.data = [response.data];
                }
                return response;
            })
                .catch((error) => {
                if (isListReferencesRequest && error.status === 404) {
                    return {
                        status: 200,
                        headers: error.headers,
                        data: []
                    };
                }
                throw error;
            });
        }
        return request(options);
    });
}
enterpriseCompatibility.VERSION = VERSION;

export { enterpriseCompatibility };
//# sourceMappingURL=index.js.map
